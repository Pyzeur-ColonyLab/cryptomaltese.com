# CryptoMaltese Production Environment Configuration
# Copy this file to .env.production and fill in your actual values

# =============================================================================
# REQUIRED CONFIGURATION
# =============================================================================

# Database Configuration (PostgreSQL)
# Format: postgresql://username:password@host:port/database
DATABASE_URL=postgresql://cryptomaltese_user:YOUR_DB_PASSWORD@your-db-host:5432/cryptomaltese

# Etherscan API Configuration
# Get your API key from: https://etherscan.io/apis
ETHERSCAN_API_KEY=YOUR_ETHERSCAN_API_KEY_HERE

# Security Secrets (GENERATE STRONG RANDOM VALUES)
# Use: openssl rand -base64 32
JWT_SECRET=YOUR_256_BIT_JWT_SECRET_HERE
SESSION_SECRET=YOUR_256_BIT_SESSION_SECRET_HERE

# =============================================================================
# SERVICE CONFIGURATION
# =============================================================================

# Node.js API Configuration
NODE_ENV=production
PORT=3000

# Graph Service Configuration
GRAPH_SERVICE_URL=http://localhost:8000
GRAPH_SERVICE_TIMEOUT_MS=35000
GRAPH_SERVICE_RETRY_ATTEMPTS=3

# =============================================================================
# PERFORMANCE TUNING
# =============================================================================

# Rate Limiting
RATE_LIMIT_WINDOW_MS=900000        # 15 minutes
RATE_LIMIT_MAX_REQUESTS=100        # 100 requests per window

# Caching
CACHE_TTL_SECONDS=600              # 10 minutes

# Etherscan API
ETHERSCAN_TIMEOUT_MS=30000         # 30 seconds
ETHERSCAN_RETRY_ATTEMPTS=3         # 3 retry attempts

# =============================================================================
# GRAPH PROCESSING CONFIGURATION
# =============================================================================

# Processing Limits
MAX_NODES_PER_GRAPH=500            # Maximum nodes per graph
MAX_API_CALLS_PER_INCIDENT=25      # Maximum Etherscan calls per incident
PROCESSING_TIMEOUT_SECONDS=30      # Processing timeout
MAX_DEPTH=8                        # Maximum traversal depth

# Value Filtering
MIN_TRANSACTION_VALUE_ETH=0.05     # Minimum transaction value to process

# Percentage Thresholds (based on hack size)
MIN_PERCENTAGE_SMALL_HACK=1.0      # For hacks < 10 ETH
MIN_PERCENTAGE_MEDIUM_HACK=0.5     # For hacks 10-100 ETH  
MIN_PERCENTAGE_LARGE_HACK=0.1      # For hacks > 100 ETH

# Classification Thresholds
HIGH_FREQUENCY_TX_THRESHOLD=100    # Transactions per day for high-frequency detection
REUSE_THRESHOLD=3                  # Address reuse threshold for consolidation

# =============================================================================
# LOGGING CONFIGURATION
# =============================================================================

# Log Levels: DEBUG, INFO, WARNING, ERROR
LOG_LEVEL=INFO
LOG_FORMAT=json

# =============================================================================
# OPTIONAL ADVANCED CONFIGURATION
# =============================================================================

# Database Connection Pooling
DATABASE_POOL_MIN_SIZE=5
DATABASE_POOL_MAX_SIZE=10
DATABASE_TIMEOUT=30

# Time-based Filtering (hours)
HIGH_PRIORITY_HOURS=6              # High priority time window
MEDIUM_PRIORITY_HOURS=72           # Medium priority time window  
LOW_PRIORITY_DAYS=30               # Low priority time window

# Service Discovery (for multi-instance deployments)
# NODE_SERVICE_URL=http://api-service:3000

# =============================================================================
# CLOUD PROVIDER SPECIFIC (uncomment as needed)
# =============================================================================

# AWS Configuration
# AWS_REGION=us-east-1
# AWS_ACCESS_KEY_ID=your_access_key
# AWS_SECRET_ACCESS_KEY=your_secret_key

# DigitalOcean Configuration  
# DO_REGION=nyc1
# DO_TOKEN=your_do_token

# =============================================================================
# SECURITY NOTES
# =============================================================================

# 1. Generate strong secrets using: openssl rand -base64 32
# 2. Store secrets in a secure manner (AWS Secrets Manager, etc.)
# 3. Use environment-specific database credentials
# 4. Restrict database access to application servers only
# 5. Enable SSL/TLS for all external connections
# 6. Regularly rotate API keys and secrets
